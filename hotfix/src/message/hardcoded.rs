//! These messages should be autogenerated eventually,
//! but for now we hard-code the ones we need from the
//! FIX 4.4 spec.
//!
use fefix::definitions::fix44;
pub use fefix::fix_values::{Date, Timestamp};
use fefix::tagvalue::{Config, Encoder, EncoderHandle, FvWrite};

#[derive(Debug, Clone)]
pub struct NewOrderSingle {
    // order details
    pub transact_time: Timestamp,
    pub symbol: String,    // CCY1/CCY2 as string
    pub cl_ord_id: String, // unique order ID assigned by the customer
    pub side: fix44::Side,
    pub order_qty: u32,
    pub settlement_date: Date,
    pub currency: String, // the dealt currency

    // allocation
    pub number_of_allocations: u32,
    pub allocation_account: String,
    pub allocation_quantity: u32,
}

#[derive(Debug, Clone)]
pub enum FixMessage {
    NewOrderSingle(NewOrderSingle),
}

pub trait IntoRawMessage {
    fn write(&self, msg: &mut EncoderHandle<Vec<u8>>);

    fn message_type(&self) -> &[u8];
}

impl IntoRawMessage for FixMessage {
    fn write(&self, msg: &mut EncoderHandle<Vec<u8>>) {
        match self {
            FixMessage::NewOrderSingle(order) => {
                // order details
                msg.set_fv(fix44::TRANSACT_TIME, order.transact_time.clone());
                msg.set_fv(fix44::SYMBOL, order.symbol.as_str());
                msg.set_fv(fix44::CL_ORD_ID, order.cl_ord_id.as_str());
                msg.set_fv(fix44::SIDE, order.side);
                msg.set_fv(fix44::ORDER_QTY, order.order_qty);
                msg.set_fv(fix44::SETTL_DATE, order.settlement_date);
                msg.set_fv(fix44::CURRENCY, order.currency.as_str());

                // allocations
                msg.set_fv(fix44::NO_ALLOCS, order.number_of_allocations);
                msg.set_fv(fix44::ALLOC_ACCOUNT, order.allocation_account.as_str());
                msg.set_fv(fix44::ALLOC_QTY, order.allocation_quantity);
            }
        }
    }

    fn message_type(&self) -> &[u8] {
        match self {
            FixMessage::NewOrderSingle(_) => b"D",
        }
    }
}

pub(crate) fn generate_message(
    sender_comp_id: &str,
    target_comp_id: &str,
    msg_seq_num: usize,
    message: impl IntoRawMessage,
) -> Vec<u8> {
    let mut buffer = Vec::new();
    let mut encoder: Encoder<Config> = Encoder::default();
    let mut msg = encoder.start_message(b"FIX.4.4", &mut buffer, message.message_type());
    msg.set_fv(fix44::SENDER_COMP_ID, sender_comp_id);
    msg.set_fv(fix44::TARGET_COMP_ID, target_comp_id.as_bytes());
    msg.set_fv(fix44::MSG_SEQ_NUM, msg_seq_num);
    msg.set_fv(fix44::SENDING_TIME, Timestamp::utc_now());

    message.write(&mut msg);

    msg.wrap().to_vec()
}
